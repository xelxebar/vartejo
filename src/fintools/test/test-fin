#!/usr/bin/env bash
shopt -s -o errexit nounset pipefail

# shellcheck source=fin
. "$(dirname "${0}")/../fin"


## Test Function 'apikey'
#

test_apikey_good_key()
{
	local apikey

	apikey="$(apikey 'alphavantage.co')"
	[[ "${apikey}" != "" ]]
}

test_apikey_bad_key()
{
	local apikey

	! apikey="$(apikey '__NONEXISTENT_KEY__' 2>/dev/null)" 
	[[ "${apikey}" == "" ]]
}

test_apikey_null_key()
{
	! apikey 2>/dev/null
}


## Test Function 'ifstdin'
#

test_ifstdin_nonempty()
{
	local input="some input"
	local output

	output=$(printf '%s' "${input}" | ifstdin cat)
	[[ "${output}" == "${input}" ]]
}

test_ifstdin_empty()
{
	local output

	! output=$(printf '' | ifstdin true)
	[[ -z "${output}" ]]
}


## Test Function 'mkrhash'
#

test_mkrhash_good_args()
{
	local -A hashmap=()
	local -a array=( 'foo' 'bar' 'baz')

	local i
	mkrhash hashmap array
	[[ ${#hashmap[@]} -eq ${#array[@]} ]]
	for i in "${!array[@]}"; do
		[[ "${hashmap["${array[i]}"]}" == "${i}" ]]
	done
}

test_mkrhash_empty_array()
{
	local -A hashmap=()
	# shellcheck disable=SC2034
	local -a empty_array=()

	mkrhash hashmap empty_array
	[[ ${#hashmap[@]} -eq 0 ]]
}

test_mkrhash_nonexistent_array()
{
	local -A hashmap=()

	mkrhash hashmap nonexistent_array
	[[ ${#hashmap[@]} -eq 0 ]]
}

test_mkrhash_nonexistent_hashmap()
{
	local -a array=( 'foo' 'bar' 'baz')

	! mkrhash nonexistent_hashmap array
}


## Test Function 'sortcols'
#

test_sortcols_column_ordering()
{
	# shellcheck disable=SC2034
	local -a colnames=( 'foo' 'bar' 'baz' )
	# shellcheck disable=SC2034
	local -A columns=(
		[baz]=0
		[foo]=1
		[bar]=2
	)
	local column_separator=','
	local text

	text="$(cat <<- EOF
		baz001,foo001,bar001
		baz002,foo002,bar002
		baz003,foo003,bar003
	EOF
	)"
	echo "${text}" \
	| sortcols columns colnames "${column_separator}" \
	| [[ "$(head -1)" == "foo001,bar001,baz001" ]]
}

test_sortcols_column_insertion()
{
	# shellcheck disable=SC2034
	local -a colnames=( 'foo' 'bar' 'baz' )
	# shellcheck disable=SC2034
	local -A columns=(
		[baz]=0
		[foo]=1
	)
	local column_separator=','
	local text

	text="$(cat <<- EOF
		baz001,foo001
		baz002,foo002
		baz003,foo003
	EOF
	)"
	echo "${text}" \
	| sortcols columns colnames "${column_separator}" \
	| [[ "$(head -1)" == "foo001,,baz001" ]]
}

test_sortcols_column_deletion()
{
	# shellcheck disable=SC2034
	local -a colnames=( 'foo' 'baz' )
	# shellcheck disable=SC2034
	local -A columns=(
		[baz]=0
		[foo]=1
		[bar]=2
	)
	local column_separator=','
	local text

	text="$(cat <<- EOF
		baz001,foo001,bar001
		baz002,foo002,bar002
		baz003,foo003,bar003
	EOF
	)"
	echo "${text}" \
	| sortcols columns colnames "${column_separator}" \
	| [[ "$(head -1)" == "foo001,baz001" ]]
}

test_sortcols_empty_sort_specification()
{
	# shellcheck disable=SC2034
	local -a colnames=()
	# shellcheck disable=SC2034
	local -A columns=(
		[baz]=0
		[foo]=1
	)
	local column_separator=','
	local text

	text="$(cat <<- EOF
		foo001,baz001
		foo002,baz002
		foo003,baz003
	EOF
	)"
	echo "${text}" \
	| sortcols columns colnames "${column_separator}" \
	| [[ -z "$(cat)" ]]
}

test_sortcols_empty_data()
{
	# shellcheck disable=SC2034
	local -a colnames=( 'foo' 'bar' 'baz' )
	# shellcheck disable=SC2034
	local -A columns=(
		[baz]=0
		[foo]=1
	)
	local column_separator=','

	local output
	! output=$( printf '' \
	          | sortcols columns colnames "${column_separator}" )
	[[ -z "${output}" ]]
}


## Test Function 'isdeclared'
#

test_isdeclared()
{
	# shellcheck disable=SC2034
	local variable

	isdeclared variable
	! isdeclared nonexistent_variable
}


## Test Function 'fetch_raw_time_series_alphavantage_co'
#

test_fetch_raw_time_series_alphavantage_co_bad_args()
{
	local apikey='dummy'
	local symbol=LF

	! fetch_raw_time_series_alphavantage_co
	! fetch_raw_time_series_alphavantage_co "${apikey}"
	! fetch_raw_time_series_alphavantage_co '' "${symbol}"
	! fetch_raw_time_series_alphavantage_co '' ''
	! fetch_raw_time_series_alphavantage_co "${apikey}" "${symbol}" \
	                                        __nonexistent_function__
	! fetch_raw_time_series_alphavantage_co "${apikey}" "${symbol}" \
	                                        default \
	                                        __nonexistent_outputsize__
	! fetch_raw_time_series_alphavantage_co "${apikey}" "${symbol}" \
	                                        default default \
	                                        __nonexistent_interval__
	! fetch_raw_time_series_alphavantage_co "${apikey}" "${symbol}" \
	                                        default default default \
	                                        __nonexistent_datatype__
}


## TODO: Implement the following tests
#

test_fetch_raw_securities_nasdaq_com() { return; }

test_postfetch_alphavantage_co_time_series() { return; }
test_postfetch_securities_nasdaq_com() { return; }

test_fetch_time_series_alphavantage_co() { return; }
test_fetch_securities_nasdaq_com() { return; }

test_fetch_time_series() { return; }
test_fetch_securities() { return; }

test_munge_filter_columns() { return; }
test_munge_metadata_header() { return; }
test_munge_emas() { return; }

test_plot_candlestick() { return; }
test_plot_linespoints() { return; }
test_plot_dgrid3d() { return; }


## Testing Infrastructure
#

## Print function backtrace
# 
# Prints the Bash function callstack backtrace when the last exit code is
# non-zero. This shouldn't be called directly but instead trap on EXIT.
print_backtrace()
{
	# shellcheck disable=SC2181
	if [[ $? -ne 0 ]]; then
		local i
		for i in $(seq 1 $(( ${#FUNCNAME[@]} - 1 ))); do
		# FUNCNAME[0] is this backtrace function, so we start from
		# index 1
			>&2 printf '%s(%s):%s\n' "${BASH_SOURCE[i]}" \
			                         "${FUNCNAME[i]}" \
			                         "${BASH_LINENO[i]}"
		done
	fi
}

## Run tests in local file
#
# Runs all functions in caller's file that begin with the string 'test'.
run_tests()
{
	local file="${0}"
	local -a tests=()
	
	tests=( $(sed --quiet 's/^\(test\w\+\)()$/\1/p' "${file}") )

	local test_func
	for test_func in "${tests[@]}"; do
		"${test_func}"
	done
}

if [[ "${BASH_SOURCE[0]}" = "${0}" ]]; then
	trap print_backtrace EXIT
	run_tests
fi
