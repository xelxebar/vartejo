#!/usr/bin/env bash
shopt -s -o errexit nounset pipefail

readonly testdir="$(dirname "${0}")"

# shellcheck source=fin
. "${testdir}/../fin"


## Test Function 'apikey'
#

test_apikey_good_key()
{
	local apikey

	apikey="$(apikey 'alphavantage.co')"
	[[ "${apikey}" != "" ]]
}

test_apikey_bad_key()
{
	local apikey

	! apikey="$(apikey '__NONEXISTENT_KEY__' 2>/dev/null)"
	[[ "${apikey}" == "" ]]
}

test_apikey_null_key()
{
	! apikey 2>/dev/null
}


## Test Function 'ifstdin'
#

test_ifstdin_nonempty()
{
	local input="some input"

	printf '%s' "${input}" \
	| ifstdin cat \
	| [[ "$(cat)" == "${input}" ]]
}

test_ifstdin_empty()
{
	printf '' \
	| ifstdin false \
	| [[ -z "$(cat)" ]]
}


## Test Function 'mkrhash'
#

test_mkrhash_good_args()
{
	local -A hashmap=()
	local -a array=( 'foo' 'bar' 'baz')

	local i
	mkrhash hashmap array
	[[ ${#hashmap[@]} -eq ${#array[@]} ]]
	for i in "${!array[@]}"; do
		[[ "${hashmap["${array[i]}"]}" == "${i}" ]]
	done
}

test_mkrhash_empty_array()
{
	local -A hashmap=()
	# shellcheck disable=SC2034
	local -a empty_array=()

	mkrhash hashmap empty_array
	[[ ${#hashmap[@]} -eq 0 ]]
}

test_mkrhash_nonexistent_array()
{
	local -A hashmap=()

	mkrhash hashmap nonexistent_array
	[[ ${#hashmap[@]} -eq 0 ]]
}

test_mkrhash_nonexistent_hashmap()
{
	local -a array=( 'foo' 'bar' 'baz')

	! mkrhash nonexistent_hashmap array
}


## Test Function 'sortcols'
#

test_sortcols_column_ordering()
{
	# shellcheck disable=SC2034
	local -a colnames=( 'foo' 'bar' 'baz' )
	# shellcheck disable=SC2034
	local -A columns=(
		[baz]=0
		[foo]=1
		[bar]=2
	)
	local column_separator=','
	local text

	text="$(cat <<- EOF
		baz001,foo001,bar001
		baz002,foo002,bar002
		baz003,foo003,bar003
	EOF
	)"
	echo "${text}" \
	| sortcols columns colnames "${column_separator}" \
	| [[ "$(head -1)" == "foo001,bar001,baz001" ]]
}

test_sortcols_column_insertion()
{
	# shellcheck disable=SC2034
	local -a colnames=( 'foo' 'bar' 'baz' )
	# shellcheck disable=SC2034
	local -A columns=(
		[baz]=0
		[foo]=1
	)
	local column_separator=','
	local text

	text="$(cat <<- EOF
		baz001,foo001
		baz002,foo002
		baz003,foo003
	EOF
	)"
	echo "${text}" \
	| sortcols columns colnames "${column_separator}" \
	| [[ "$(head -1)" == "foo001,,baz001" ]]
}

test_sortcols_column_deletion()
{
	# shellcheck disable=SC2034
	local -a colnames=( 'foo' 'baz' )
	# shellcheck disable=SC2034
	local -A columns=(
		[baz]=0
		[foo]=1
		[bar]=2
	)
	local column_separator=','
	local text

	text="$(cat <<- EOF
		baz001,foo001,bar001
		baz002,foo002,bar002
		baz003,foo003,bar003
	EOF
	)"
	echo "${text}" \
	| sortcols columns colnames "${column_separator}" \
	| [[ "$(head -1)" == "foo001,baz001" ]]
}

test_sortcols_empty_sort_specification()
{
	# shellcheck disable=SC2034
	local -a colnames=()
	# shellcheck disable=SC2034
	local -A columns=(
		[baz]=0
		[foo]=1
	)
	local column_separator=','
	local text

	text="$(cat <<- EOF
		foo001,baz001
		foo002,baz002
		foo003,baz003
	EOF
	)"
	echo "${text}" \
	| sortcols columns colnames "${column_separator}" \
	| [[ -z "$(cat)" ]]
}

test_sortcols_empty_data()
{
	# shellcheck disable=SC2034
	local -a colnames=( 'foo' 'bar' 'baz' )
	# shellcheck disable=SC2034
	local -A columns=(
		[baz]=0
		[foo]=1
	)
	local sep=','

	printf '' \
	| sortcols columns colnames "${sep}" \
	| [[ -z "$(cat)" ]]
}


## Test Function 'isdeclared'
#

test_isdeclared()
{
	# shellcheck disable=SC2034
	local variable

	isdeclared variable
	! isdeclared nonexistent_variable
}


## Test Function 'fetch_raw_time_series_alphavantage_co'
#

test_fetch_raw_time_series_alphavantage_co_bad_args()
{
	local apikey='dummy'
	local symbol=LF

	! fetch_raw_time_series_alphavantage_co
	! fetch_raw_time_series_alphavantage_co "${apikey}"
	! fetch_raw_time_series_alphavantage_co '' "${symbol}"
	! fetch_raw_time_series_alphavantage_co '' ''
	! fetch_raw_time_series_alphavantage_co "${apikey}" "${symbol}" \
	                                        __nonexistent_function__
	! fetch_raw_time_series_alphavantage_co "${apikey}" "${symbol}" \
	                                        default \
	                                        __nonexistent_outputsize__
	! fetch_raw_time_series_alphavantage_co "${apikey}" "${symbol}" \
	                                        default default \
	                                        __nonexistent_interval__
	! fetch_raw_time_series_alphavantage_co "${apikey}" "${symbol}" \
	                                        default default default \
	                                        __nonexistent_datatype__
}


## Test Function 'fetch_raw_securities_nasdaq_com'
#

test_fetch_raw_securities_nasdaq_com_bad_args()
{
	! fetch_raw_securities_nasdaq_com __nonexistent_symbol__
}


## Test Function 'postfetch_time_series_alphavantage_co'
#

test_postfetch_time_series_alphavantage_co_well_formed_output()
{
	local data="${testdir}/res/raw/LF-daily-100-alphavantage.co.csv"
	local sep="${setting[csv-separator]}"

	postfetch_time_series_alphavantage_co <"${data}" \
	| [[ "$(colcount "${sep}")" -eq "${#columns_time_series[@]}" ]]
}

test_postfetch_time_series_alphavantage_co_empty_input()
{
	printf '' \
	| postfetch_time_series_alphavantage_co \
	| [[ -z "$(cat)" ]]
}

test_postfetch_time_series_alphavantage_co_upstream_error()
{
	local data="${testdir}/res/raw/error-alphavantage.co.json"

	! postfetch_time_series_alphavantage_co <"${data}" 2>/dev/null
}


## Test Function 'postfetch_securities_nasdaq_com'

test_postfetch_securities_nasdaq_com_well_formed_output()
{
	local data="${testdir}/res/raw/NYSE-nasdaq.com.csv"
	local sep="${setting[csv-separator]}"

	postfetch_securities_nasdaq_com <"${data}" \
	| [[ "$(colcount "${sep}")" -eq "${#columns_securities_list[@]}" ]]
}

test_postfetch_securities_nasdaq_com_empty_input()
{
	printf '' \
	| postfetch_securities_nasdaq_com \
	| [[ -z "$(cat)" ]]
}


## Test Function 'fetch_time_series_alphavantage_co'
#

test_fetch_time_series_alphavantage_co_bad_args()
{
	local symbol="DUMMY"

	! fetch_time_series_alphavantage_co
	! fetch_time_series_alphavantage_co "${symbol}" \
	                                    __nonexistent_function__
	! fetch_time_series_alphavantage_co "${symbol}" default \
	                                    __nonexistent_outputsize__
	! fetch_time_series_alphavantage_co "${symbol}" default default \
	                                    __nonexistent_interval__
}


## Test Function 'fetch_securities_nasdaq_com'
#

test_fetch_securities_nasdaq_com_bad_args()
{
	! fetch_securities_nasdaq_com __nonexistent_symbol__
}


## Test Function 'fetch_time_series'

test_fetch_time_series_bad_args()
{
	local symbol='LF'

	! fetch_time_series __nonexistent_symbol__  2>/dev/null
	! fetch_time_series "${symbol}" __nonexistent_function__
	! fetch_time_series "${symbol}" default __nonexistent_outputsize__
	! fetch_time_series "${symbol}" default default \
	                                __nonexistent_interval__
}

## Test Function 'fetch_securities'
#

test_fetch_securities_bad_args()
{
	local symbol='NYSE'

	! fetch_securities __nonexistent_symbol__
}


## Test Function 'munge_filter_columns'
#

test_munge_filter_columns_column_count()
{
	local data="${testdir}/res/time-series/LF-daily-100.csv"
	local sep="${setting[csv-separator]}"
	local -a cols=(0 1 2)
	
	munge_filter_columns "${cols[@]}" <"${data}" \
	| [[ "$(colcount "${sep}")" -eq ${#cols[@]} ]]
}

test_munge_filter_columns_empty_input()
{
	local sep="${setting[csv-separator]}"
	local -a cols=(0 1 2)
	
	printf '' \
	| munge_filter_columns "${cols[@]}" \
	| [[ -z "$(cat)" ]]
}

test_munge_filter_columns_empty_column_list()
{
	local data="${testdir}/res/time-series/LF-daily-100.csv"
	local -a cols=()

	munge_filter_columns <"${data}" \
	| [[ -z "$(cat)" ]]
	
	munge_filter_columns "${cols[@]}" <"${data}" \
	| [[ -z "$(cat)" ]]
}


## Test Function 'munge_metadata_header'
#

test_munge_metadata_header_format()
{
	local data="${testdir}/res/time-series/LF-daily-100.csv"
	local header="${testdir}/res/header/LF-daily-100-maximal.csv"
	local -a hcols=(
		"${_ts[id]}"
		"${_ts[open]}"
		"${_ts[high]}"
		"${_ts[low]}"
		"${_ts[close]}"
		"${_ts[volume]}"
	)

	munge_metadata_header "${hcols[@]}" <"${data}" \
	| head --lines=$(( ${#hcols[@]} + 1 )) \
	| [[ "$(cat)" == "$(cat "${header}")" ]] \
	|| [[ $? -eq ${ERRPIPE} ]]
}

test_munge_metadata_header_empty_column_list()
{
	local data="${testdir}/res/time-series/LF-daily-100.csv"
	local header="${testdir}/res/header/LF-daily-100-minimal.csv"
	local -a hcols=()

	munge_metadata_header "${hcols[@]}" <"${data}" \
	| head --lines=$(( ${#hcols[@]} + 1 )) \
	| [[ "$(cat)" == "$(cat "${header}")" ]] \
	|| [[ $? -eq ${ERRPIPE} ]]

	munge_metadata_header <"${data}" \
	| head --lines=$(( ${#hcols[@]} + 1 )) \
	| [[ "$(cat)" == "$(cat "${header}")" ]] \
	|| [[ $? -eq ${ERRPIPE} ]]
}


## Test Function 'munge_multi_ema'
#

test_munge_multi_ema_good_args()
{
	local ts_data="${testdir}/res/time-series/LF-daily-100.csv"
	local ema_data="${testdir}/res/multi-ema/LF-daily-100-0.8.csv"
	local idcol="${_ts[id]}"
	local datacol="${_ts[close]}"
	local w="${setting[ema-weight]}"

	munge_multi_ema "${idcol}" "${datacol}" "${w}" <"${ts_data}" \
	| [[ "$(cat)" == "$(cat "${ema_data}")" ]]
}

test_munge_multi_ema_bad_id_column()
{
	local ts_data="${testdir}/res/time-series/LF-daily-100.csv"
	local idcol=-1
	local datacol="${_ts[close]}"
	local w="${setting[ema-weight]}"

	! munge_multi_ema "${idcol}" "${datacol}" "${w}" <"${ts_data}"
	! munge_multi_ema "" "${datacol}" "${w}" <"${ts_data}"
}

test_munge_multi_ema_bad_data_column()
{
	local ts_data="${testdir}/res/time-series/LF-daily-100.csv"
	local idcol="${_ts[id]}"
	local datacol=-1
	local w="${setting[ema-weight]}"

	! munge_multi_ema "${idcol}" "${datacol}" "${w}" <"${ts_data}"
	! munge_multi_ema "${idcol}" "" "${w}" <"${ts_data}"
}

test_munge_multi_ema_bad_weight()
{
	local ts_data="${testdir}/res/time-series/LF-daily-100.csv"
	local idcol="${_ts[id]}"
	local datacol="${_ts[close]}"

	! munge_multi_ema "${idcol}" "${datacol}" -100 <"${ts_data}"
	! munge_multi_ema "${idcol}" "${datacol}" 100 <"${ts_data}"
}

test_munge_multi_ema_empty_input()
{
	local ts_data="${testdir}/res/time-series/LF-daily-100.csv"
	local idcol="${_ts[id]}"
	local datacol="${_ts[close]}"
	local w="${setting[ema-weight]}"

	printf '' \
	| munge_multi_ema "${idcol}" "${datacol}" "${w}" \
	| [[ -z "$(cat)" ]]
}

test_munge_multi_ema_missing_args()
{
	local idcol="${_ts[id]}"

	! munge_multi_ema
	! munge_multi_ema "${idcol}"
}


## TODO: Implement the following tests
#

test_plot_candlestick() { return; }
test_plot_linespoints() { return; }
test_plot_dgrid3d() { return; }


## Testing Infrastructure
#

declare ERRPIPE
ERRPIPE=$(( $(kill -l SIGPIPE) + 128 ))

## Count of columns in stdin
#
# @param <1>  Column separator
colcount()
{
	local sep="${1}"

	awk --field-separator "${sep}" 'END {print NF}'
}

## Print function backtrace
#
# Prints the Bash function callstack backtrace when the last exit code is
# non-zero. This shouldn't be called directly but instead trap on EXIT.
print_backtrace()
{
	# shellcheck disable=SC2181
	if [[ $? -ne 0 ]]; then
		local i
		for i in $(seq 1 $(( ${#FUNCNAME[@]} - 1 ))); do
		# FUNCNAME[0] is this backtrace function, so we start from
		# index 1
			>&2 printf '%s(%s):%s\n' "${BASH_SOURCE[i]}" \
			                         "${FUNCNAME[i]}" \
			                         "${BASH_LINENO[i]}"
		done
	fi
}

## Run tests in local file
#
# Runs all functions in caller's file that begin with the string 'test'.
run_tests()
{
	local file="${0}"
	local -a tests=()

	tests=( $(sed --quiet 's/^\(test\w\+\)()$/\1/p' "${file}") )

	local test_func
	for test_func in "${tests[@]}"; do
		"${test_func}"
	done
}

if [[ "${BASH_SOURCE[0]}" = "${0}" ]]; then
	trap print_backtrace EXIT
	run_tests
fi
