#!/usr/bin/env bash
shopt -s -o errexit nounset pipefail

# MIT License
#
# Copyright (c) 2017 Brandon Wilson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# A micro testing framework for bash
#
# Tests are just bash functions that begin with the word `test'. A return value
# of 0 is success and otherwise failure.
#
# The function 'utest_run' will run all tests in a specified file, or default
# to the caller's file if left unspecified. Typically usage is to include the
# following snipped at the end of a test suite:
#
#     if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
#             . path/to/utest
#             utest_run
#     fi
#
# A successful test run should output TAPS-like diagnostics and will bail out
# with a function call backtrace if an error is encountered.


# shellcheck disable=SC2034
declare ERRPIPE=$(( $(kill -l SIGPIPE) + 128 ))


## Helper Functions
#

## Count of columns in stdin
#
# @param <1>  Column separator
colcount()
{
	local sep="${1}"

	awk --field-separator "${sep}" 'END {print NF}'
}


## Test Framework Functions
#

## Print function backtrace
#
# Prints the Bash function callstack backtrace when the last exit code is
# non-zero. This shouldn't be called directly but instead trap on EXIT.
utest_backtrace()
{
	# shellcheck disable=SC2181
	if [[ $? -ne 0 ]]; then
		printf 'not ok %s - %s\n' "${TEST_COUNT}" "${TEST_FUNCTION}"
		printf 'Bail out! Encountered error\n'

		local i
		for i in $(seq 1 $(( ${#FUNCNAME[@]} - 1 ))); do
		# FUNCNAME[0] is this backtrace function, so we start from
		# index 1
			>&2 printf '# %s(%s):%s\n' "${BASH_SOURCE[i]}" \
			                           "${FUNCNAME[i]}" \
			                           "${BASH_LINENO[i]}"
		done
	fi
}

## Run all tests in a file
#
# Runs all functions in caller's file that begin with the string 'test'.
#
# @param [1..]  Explicit list of tests to run
utest_run()
{
	local -a tests=("${@}")
	local file="${0}"

	if [[ ${#tests[@]} -eq 0 ]]; then
		tests=( $(sed --quiet 's/^\(test\w\+\)()$/\1/p' "${file}") )
	fi

	trap utest_backtrace EXIT
	printf '1..%s\n' "${#tests[@]}"

	local TEST_COUNT=0
	local TEST_FUNCTION
	for TEST_FUNCTION in "${tests[@]}"; do
		TEST_COUNT=$((TEST_COUNT + 1))
		"${TEST_FUNCTION}"
		printf 'ok %s - %s\n' "${TEST_COUNT}" "${TEST_FUNCTION}"
	done
}
