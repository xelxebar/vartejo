#!/usr/bin/env bash
set -euo pipefail

# MIT License
# 
# Copyright (c) 2017 Brandon Wilson
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# A tool for processing securities and equities
#
# Conceptually, this program is a pipeline to process data. The birds-eye view
# of data flow is as follows:
#
#     Fetch Data >> Munge Data >> Visualize Data.
#
# At each stage data is read from stdin, processed and written to stdout.
#
# The ``Fetch Data'' stage is primarily responsible for downloading raw data
# from relevant ``vendors'' and postprocessing that vendor-specific data into
# this program's internal data format:
#
#     Fetch Raw Data >> Postproces.
#
# It's important to note that this step should never result in data-loss.
#
# The internal data format is just CSV without a header line. Metadata is also
# just represented as a CSV header prepended to the data CSV and separated by a
# newline, similar to HTTP, SMTP etc. Visually,
#
#     <header field><sep><header field><sep>...
#
#     <data field><sep><data field><sep>...
#     <data field><sep><data field><sep>...
#     ...
#
# NOTE: CSV is well suited to line-oriented processing; however the format
# becomes ambiguous when the field separator can appear in the data. To
# circumvent this, the field separator is configurable via the
# '${setting[csv-separator]}' variable.
#
# The ``Munge Data'' is where the actual math happens. It expects
# well-formatted data and ``munges'' it by performing whatever calculation is
# of interest. The output should also be a well-formatted CSV. After this step
# the original data will likely be processed away.
#
# Finally, the ``Visualize Data'' step is responsible presenting the processed
# data to the user. This may vary from simple CSV column-selection to complex
# 3D graphs.


### Global Settings and Parameters
#  

readonly -A setting=(
	[plot-vert-padding]=0.1
	[plot-candlestick-neg-color]='red'
	[plot-candlestick-pos-color]='green'
	[plot-dgrid3d-mesh-size]=100
	[ema-weight]=0.8
	[ema-min]=0.0
	[ema-max]=1.0
	[ema-bin-count]=100
	[csv-separator]=$'\t'
)

readonly -A csvcol=(
	[id]=1
	[date]=2
	[open]=3
	[high]=4
	[low]=5
	[close]=6
	[volume]=7
	[weight]=3
	[ema]=4
)

readonly -A error=(
	[bad-args]=101
	[bad-cmd]=102
	[stdin-empty]=201
)


### Vendor-Independent API
#

## Vendor-independent function for fetching time series data
#
# @param <1>  Stock symbol
# @param [2]  Function
# @param [3]  Output size
# @param [4]  Interval
fetch_csv_time_series()
{
	local symbol="${1}"
	local function="${2-default}"
	local outputsize="${3-default}"
	local interval="${4-default}"

	fetch_csv_time_series_alphavantage_co "${symbol}" \
	                                      "${function}" \
	                                      "${outputsize}" \
	                                      "${interval}"
}

## Vendor-independent function for fetching exchange company list
#
# @param <1>  Symbol of stock exchange
fetch_csv_exchange_company_list()
{
	local symbol="${1}"

	fetch_csv_exchange_company_list_nasdaq_com "${symbol}"
}


### Vendor-Specific API

## Fetch data from alphavantage.co and process into internal format
#
# @param <1>  Stock symbol
# @param [2]  Function
# @param [3]  Output size
# @param [4]  Interval
fetch_csv_time_series_alphavantage_co()
{
	local apikey
	local symbol="${1}"
	local function="${2-default}"
	local outputsize="${3-default}"
	local interval="${4-default}"
	apikey="$(apikey alphavantage.co)"

	fetch_raw_time_series_alphavantage_co "${apikey}" \
	                                      "${symbol}" \
	                                      "${function}" \
	                                      "${outputsize}" \
	                                      "${interval}" \
	                                      csv \
	| postfetch_csv_alphavantage_co_time_series
}

## Fetch and postprocess exchange company list data from nasdaq.com
fetch_csv_exchange_company_list_nasdaq_com()
{
	fetch_exchange_company_list_nasdaq_com "${@}" \
	| postfetch_csv_exchange_company_list_nasdaq_com
}


### Fetch and Postprocess Raw Vendor Data
#

## Fetch raw data from alphavantage.co
#
# @param <1>  API key
# @param <2>  Stock symbol
# @param [3]  Function
# @param [4]  Output size
# @param [5]  Interval
# @param [6]  Datatype
# @stdout     result
fetch_raw_time_series_alphavantage_co()
{
	[[ ${#} -lt 2 ]] && return "${error[bad-args]}"
	[[ -z "${1}" ]] && return "${error[bad-args]}"
	[[ -z "${2}" ]] && return "${error[bad-args]}"

	local url='https://www.alphavantage.co'
	local path="query"
	local query=""

	local -A function=(
		[intraday]='TIME_SERIES_INTRADAY'
		[daily]='TIME_SERIES_DAILY'
		[daily-adjusted]='TIME_SERIES_DAILY_ADJUSTED'
		[weekly]='TIME_SERIES_WEEKLY'
		[monthly]='TIME_SERIES_MONTHLY'
		[default]="${function[daily]}"
	)
	local -A outputsize=(
		[compact]='compact'
		[full]='full'
		[default]="${outputsize[compact]}"
	)
	local -A interval=(
		[1min]='1min'
		[5min]='5min'
		[15min]='15min'
		[30min]='30min'
		[60min]='60min'
		[default]="${interval[60min]}"
	)
	local -A datatype=(
		[json]='json'
		[csv]='csv'
		[default]="${datatype[csv]}"
	)

	local -A field=(
	        [apikey]="${1}"
		[symbol]="${2}"
	        [function]="${function[${3-default}]}"
	        [outputsize]="${outputsize[${4-default}]}"
	        [interval]="${interval[${5-default}]}"
	        [datatype]="${datatype[${6-default}]}"
	)

	for f in "${!field[@]}"; do
		query+="&${f}=${field[${f}]}"
	done
	query="${query#&}"

	curl --silent "${url}/${path}?${query}"
}

## Postprocess alphavantage.co CSV result
postfetch_csv_alphavantage_co_time_series()
{
	local sep="${setting[csv-separator]}"
	IFS= read -r

	sed "s/\\r$//;
	     s/,/${sep}/g" \
	| nl --number-width=1 --number-separator="${sep}"
}

## Fetch raw company list in stock exchanges from nasdaq.com
#
# @param <1>  Symbol of exchange
fetch_raw_exchange_company_list_nasdaq_com()
{
	local symbol="${1}"
	local url='http://www.nasdaq.com'
	local path='screening/companies-by-industry.aspx'
	local -A index=(
		[NASDAQ]='NASDAQ'
		[NYSE]='NYSE'
		[AMEX]='AMEX'
	)
	local query="render=download&exchange=${index[${symbol}]}"

	curl --silent "${url}/${path}?${query}"
}

## Postprocess nasdaq.com CSV result into internal format
postfetch_csv_exchange_company_list_nasdaq_com()
{
	IFS= read -r

	sed 's/^"//;
	     s/",\r//;
	     s/","/'"${sep}"'/g;' \
	| nl --number-width --number-separator="${sep}"
}


### Data Mungers
#

## Prepend metadata header
#
# @param <1>  Column that contains data minimum
# @param <2>  Column that contains data maximum 
munge_csv_prepend_header()
{
	local mincol="${1}"
	local maxcol="${2}"
	local sep="${setting[csv-separator]}"
	local low high range count
	local dat=""

	low=$(getconf INT_MAX)
	high=$(getconf INT_MIN)

	while IFS= read -r l; do
		local llow
		local lhigh

		llow=$(cut -d"${sep}" -f"${mincol}" <<<"${l}")
		lhigh=$(cut -d"${sep}" -f"${maxcol}" <<<"${l}")

		if [[ $(bc <<<"${llow} < ${low}") -eq 1 ]]; then
			low=${llow}
		fi
		if [[ $(bc <<<"${lhigh} > ${high}") -eq 1 ]]; then
			high=${lhigh}
		fi

		dat+=$'\n'"${l}"
	done

	dat="${dat#\\n}"
	range=$(bc <<<"${high} - ${low}")
	count=$(tail -1 <<<"${dat}" | cut -d"${sep}" -f1)

	printf '%s%s%s%s%s%s%s\n' "${high}" \
		         "${sep}" "${low}" \
		         "${sep}" "${range}" \
		         "${sep}" "${count}"
	printf '%s' "${dat}"
}

## Generate EMA column(s) from input column
#
# @params <1, ..>  Exponential weight(s)
munge_csv_emas()
{
	local -a weight=("${@}")
	local sep="${setting[csv-separator]}"

	local w
	for w in "${weight[@]}"; do
		if [[ $(bc <<<"${w} <  0") -eq 1 ]] \
		|| [[ $(bc <<<"${w} >  1") -eq 1 ]]; then
			return "${error[bad-arg]}"
		fi
	done

	local id date open high low close volume
	IFS="${sep}" read -r id date open high low close volume

	local -a sum=()
	local -a meas=()
	for w in "${weight[@]}"; do
		sum+=("${close}")
		meas+=(1)
		printf '%s%s%s%s%s%s%s\n' "${id}" \
		                 "${sep}" "${date}" \
		                 "${sep}" "${w}" \
		                 "${sep}" "${close}"
	done

	while IFS="${sep}" read -r id date open high low close volume; do
		local -a ema=()
		local bcmeas=""
		local bcsum=""
		local bcema=""

		local i
		for i in $(seq 0 $(( ${#weight[@]} - 1 ))); do
			bcmeas+="${meas[i]} * ${weight[i]} + 1;"
			bcsum+="${sum[i]} * ${weight[i]} + ${close};"
			bcema+="${sum[i]}/${meas[i]};"
		done

		meas=( $(bc <<<"${bcmeas}") )
		sum=( $(bc <<<"${bcsum}") )
		ema=( $(bc <<<"${bcema}") )

		for i in $(seq 0 $(( "${#ema[@]}" - 1 ))); do
			printf '%s%s%s%s%s%s%s\n' "${id}" \
			                 "${sep}" "${date}" \
			                 "${sep}" "${weight[i]}" \
			                 "${sep}" "${ema[i]}"
		done
	done
}


### Data Visualization Functions
#

## Colorized candlestick plot in X11
#
# @param [1]  Color for losses
# @param [2]  Color for gains
# @param [3]  Fraction of visual padding on top and bottom of graph
plot_candlestick()
{
	local negcolor="${1-red}"
	local poscolor="${2-green}"
	local pad="${3-0}"
	local sep="${setting[csv-separator]}"
	local negval=-1
	local posval=1
	local high low range count
	local xmin xmax ymin ymax
	IFS="${sep}" read -r high low range count
	IFS= read -r

	xmin=0
	xmax=$(( count + 1 ))
	ymin=$(bc <<<"${low}  - ${range} * ${pad}")
	ymax=$(bc <<<"${high} + ${range} * ${pad}")

	ifstdin gnuplot --persist -e "
		set datafile separator '${sep}';

		set xrange [${xmin}:${xmax}];
		set yrange [${ymin}:${ymax}];

		set palette defined ( ${negval} '${negcolor}'
		                    , ${posval} '${poscolor}' );
		set cbrange [${negval}:${posval}];
		unset colorbox;
		set style fill solid noborder;

		plot '<cat' using ${csvcol[id]}
		                  :${csvcol[open]}
		                  :${csvcol[low]}
		                  :${csvcol[high]}
		                  :${csvcol[close]}
		                  :(\$${csvcol[close]} < \$${csvcol[open]}
		                    ? ${negval}
		                    : ${posval})
		            with candlesticks
		            palette
		            notitle;
	"
}

## Simple line plot
#
# @param [1]  Plot x-axis column
# @param [2]  Plot y-axis column
# @param [3]  Fraction of visual padding on top and bottom of graph
plot_linespoints()
{
	local xcol=${1-${csvcol[id]}}
	local ycol=${2-${csvcol[close]}}
	local pad="${3-0}"
	local sep="${setting[csv-separator]}"
	local high low range count
	local xmin xmax ymin ymax
	IFS="${sep}" read -r high low range count
	IFS= read -r

	xmin=0
	xmax=$(( count + 1 ))
	ymin=$(bc <<<"${low}  - ${range} * ${pad}")
	ymax=$(bc <<<"${high} + ${range} * ${pad}")

	ifstdin gnuplot --persist -e "
		set datafile separator '${sep}';

		set xrange [${xmin}:${xmax}];
		set yrange [${ymin}:${ymax}];

		plot '<cat' using ${xcol} : ${ycol}
		            with linespoints
		            notitle;
	"
}

## 3D surface plot
#
# @param <1>  Plot x-axis column
# @param <2>  Plot y-axis column
# @param <3>  Plot z-axis column
# @param [4]  Plot mesh size
plot_dgrid3d()
{ (
	local xcol="${1}"
	local ycol="${2}"
	local zcol="${3}"
	local meshsz="${4-${setting[plot-dgrid3d-mesh-size]}}"
	local sep="${setting[csv-separator]}"
	local dat

	dat=$(mktemp)
	trap 'rm '"${dat}" EXIT
	cat >"${dat}"

	gnuplot --persist -e "
		set datafile separator '${sep}';
		set dgrid3d ${meshsz}, ${meshsz};

		splot '${dat}' using ${xcol} : ${ycol} : ${zcol}
		             with lines
		             notitle;

		pause mouse close
	"
) }


### Command Functions
#

cmd_csv_time_series()
{
	fetch_csv_time_series "${@}"
}

cmd_plot_candle()
{
	fetch_csv_time_series "${@}" \
	| munge_csv_prepend_header "${csvcol[low]}" "${csvcol[high]}" \
	| plot_candlestick "${setting[plot-candlestick-neg-color]}" \
	                   "${setting[plot-candlestick-pos-color]}" \
	                   "${setting[plot-vert-padding]}"
}

cmd_plot_ema()
{
	fetch_csv_time_series "${@}" \
	| munge_csv_emas "${setting[ema-weight]}" \
	| munge_csv_prepend_header "${csvcol[ema]}" "${csvcol[ema]}" \
	| plot_linespoints "${csvcol[id]}" "${csvcol[ema]}" \
	                   "${setting[plot-vert-padding]}"
}

cmd_plot_emas()
{
	local n="${setting[ema-bin-count]}"
	local max="${setting[ema-max]}"
	local min="${setting[ema-min]}"
	local -a weights=()
	local d

	d=$(bc <<<"(${max} - ${min})/${n}")

	local i
	for i in $(seq 0 "${n}"); do
		local w
		w=$(bc <<<"${min} + ${i}*${d}")
		weights+=("${w}")
	done

	fetch_csv_time_series "${@}" \
	| munge_csv_emas "${weights[@]}" \
	| plot_dgrid3d "${csvcol[id]}" "${csvcol[weight]}" "${csvcol[ema]}" 
}

usage()
{
	cat <<- EOF
	Usage: $(basename "${0}") <command> <command args>

	Commands

	    plot-candle <symbol> [function] [output size] [interval]
	    plot-ema <symbol> [function] [output size] [interval]
	    plot-emas candle <symbol> [function] [output size] [interval]

	Command Args

	    function = < intraday | daily | daily-adjusted | weekly | monthly >
	    outputsize = < compact | full >
	    interval = < 1min | 5min | 15min | 30min | 60min >

	EOF
}


### Helper Functions
#

apikey()
{
	local key="${1}"
	local -A uid=(
		[alphavantage.co]="co/alphavantage/x@wilsonb.com/api-key"
	)

	pass show "${uid[${key}]}"
}

## Run command if stdin is non-empty
#
# @param  <1>    Command
# @params [2..]  Command arguments
ifstdin()
{
	local stdin_first_byte
	local cmd="${1}"; shift
	local -a args=("${@}")

	stdin_first_byte=$( dd bs=1 count=1 2>/dev/null \
	                  | od --format=o1 --address-radix=n \
	                  | sed 's/^\s\+//' )

	if [[ -z "${stdin_first_byte}" ]]; then
		return "${error[stdin-empty]}"
	else
		( printf '%b' "\\${stdin_first_byte}"
		  cat ) \
		| "${cmd}" "${args[@]}"
	fi
}


### Main UI and Options Processing
#

main()
{
	if [[ ${#} -eq 0 ]]; then
		usage
		return "${error[bad-cmd]}"
	fi

	local cmd="${1}"
	shift

	case "${cmd}" in
		csv-time-series) cmd_csv_time_series "${@}";;
		plot-candle) cmd_plot_candle "${@}";;
		plot-ema) cmd_plot_ema "${@}";;
		plot-emas) cmd_plot_emas "${@}";;
		_debug) "${@}";;
		*) usage;;
	esac
}

if [[ "${BASH_SOURCE[0]}" = "${0}" ]]; then
	main "${@}"
fi
