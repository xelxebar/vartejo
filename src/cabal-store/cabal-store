#! /usr/bin/env sh
# vim: filetype=sh :

function __init__ () {
#--- Module Start  ---#


### Global Variables ###

typeset -A ErrCode
ErrCode[100]="I/O Errors"
ErrCode[MisingExec]=110
ErrCode[PathEmpty]=120
ErrCode[PathInaccessible]=130
ErrCode[FileExists]=140
ErrCode[MissingPathComponent]=150

ErrCode[200]="Command Argument Errors"
ErrCode[UnknownArg]=210
ErrCode[UnrecognizedCommand]=220

ErrCode[300]="Config File Errors"
ErrCode[ConfigIncompatible]=310

ErrCode[1000]="JSON Errors"
ErrCode[UnsupportedJson]=1010

typeset -A Command
Command[StartIndex]=0
Command[Init]="init"
Command[Install]="install"
Command[Remove]="uninstall"
Command[Sync]="sync"
Command[List]="list"
Command[Help]="help"

typeset -A Conf
Conf[SupportedVersion]="0.0.1"
Conf[Description]="description"
Conf[Version]="config-version"
Conf[Path]="paths"
Conf[BinDir]="bin"
Conf[StoreDir]="store"
Conf[Packages]="packages"
Conf[PackageExtraDeps]="extra-deps"
Conf[PackageBins]="bins"

typeset -A Default
Default[BasePath]="${HOME}/.cabal-store"
Default[ConfigPath]="${Default[BasePath]}/store.conf"
Default[StorePath]="${Default[BasePath]}/store"
Default[BinPath]="${Default[BasePath]}/bin"

typeset -A Path
Path[Config]=""
Path[BinDir]=""
Path[StoreDir]=""
Path[SandboxBinDir]=".cabal-sandbox/bin"
Path[CabalLog]=".cabal-sandbox/logs/build.log"

typeset -A Opt
Opt[ConfigPath]=""
Opt[StorePath]=""
Opt[BinPath]=""


### Helper Functions ###

function arrayDifference () {
  if [[ ${#} != 2 ]]; then
    exit -1
  fi

  local A=(${1})
  local B=(${2})
  local C=()

  for p in "${A[@]}"; do
    local isUnique="true"

    for q in "${B[@]}"; do
      if [[ ${p} == ${q} ]]; then
        isUnique="false"
        break
      fi
    done

    [[ ${isUnique} == "false" ]] || C+=("${p}")
  done

  echo ${C[@]}
}


### Getters and Setters ###

function getErrCode () {
  local key=${1}

  echo ${ErrCode[${key}]}
}

function getCommand () {
  local key=${1}

  echo ${Command[${key}]}
}

function getPath () {
  local key=${1}
  local pkg=${2}
  local path=${Path["${key}"]}

  if [[ "${key}" == "CabalLog" ||
        "${key}" == "SandboxBinDir" ]] &&
       [[ -n "${pkg}" || $(errMissingPathComponent "${key}") ]]; then
    path="$(getPath StoreDir ${pkg})/${path}"
  elif [[ "${key}" == "StoreDir" ]] &&
         [[ -n "${pkg}" || $(errMissingPathComponent "${key}") ]]; then
    path="${path}/${pkg}"
  fi

  echo "${path}"
}

function setPath () {
  local key=${1}
  local path=${2}

  if [[ -z "${path}" ]]; then
    errPathEmpty "${key}"
  elif [[ ! -e "${path}" ]]; then
    errPathInaccessible "${path}"
  fi

  Path["${key}"]="${path}"
}

function setPathFromConfig () {
  local key=${1}
  local rawPath="$(getConfigProp Path ${key})"
  local absolutePath=""

  if [[ "$(realpath ${rawPath})" == "${rawPath}" ]]; then
    absolutePath="${rawPath}"
  else
    absolutePath="$(dirname $(getPath Config))/${rawPath}"
  fi

  setPath "${key}" "${absolutePath}"
}

function getConf () {
  local key=${1}

  echo "${Conf[${key}]}"
}

function getDefault () {
  local key=${1}

  echo ${Default["${key}"]}
}

function setOpt () {
  local key=${1}
  local value=${2}

  Opt["${key}"]="${value}"
}

function getOpt () {
  local key=${1}

  echo ${Opt["${key}"]}
}

function getConfigProp () {
  local props=${@}
  local spec=""
  local type=""

  for prop in ${props}; do
    local selector=$(getConf ${prop})

    if [[ -z "${selector}" ]]; then
      selector=${prop}
    fi

    spec="${spec}.\"${selector}\""
  done

  type=$(jq -r "${spec}|type" "$(getPath Config)")
  
  if [[ ${type} == "number" ||
        ${type} == "boolean" ||
        ${type} == "string" ]]; then
    jq -r "${spec}" "${Path[Config]}"
  elif [[ ${type} == "array" ]]; then
    jq -r "${spec}|join(\" \")" "$(getPath Config)"
  elif [[ ${type} == "object" ]]; then
    jq -r "${spec}|keys|join(\" \")" "$(getPath Config)"
  elif [[ ${type} == "null" ]]; then
    echo ""
  else
    errUnsupportedJson "${spec}"
  fi
}


### Path Construction ###

function getBinPaths () {
  local key=${1}
  local pkg=${2}
  local paths=()
  local bins=($(getConfigProp Packages ${pkg} PackageBins))
  local pathDir="$(getPath ${key} ${pkg})"

  [[ ${#bins} -eq 0 ]] && bins=(${pkg})

  for bin in ${bins[*]}; do
    paths+=" ${pathDir}/${bin}"
  done

  echo ${paths[*]}
}


### Printing Functions ###

function printUsage () {
  local exePath=${1}
  local exeName=$(basename "${exePath}")

  cat <<-USAGE
  Usage: ${exeName} [<option list>] <command>

  OPTION LIST

    -c <config path>

          Declare path to config file.

    -s <store path>

          Declare path to the "store" directory, where individual
          packages are installed.

    -b <bin path>

          Declare path to the "bin" directory, where symlinks to
          package executables are installed.

  COMMAND LIST

    $(getCommand Init)
          
          Initialize the cabal store.

    $(getCommand Install) <package list>

          Install the list of packages in <package list> into the
          cabal store.

    $(getCommand Remove) <package list>

          Uninstall the list of packages in <package list> from the
          cabal store.

    $(getCommand Sync)
          
          Synchronize the installed packages to the ones declare in
          config file.

    $(getCommand List)

          List all packages currently installed in the store.

    $(getCommand Help)
    
          Print this help.
USAGE
}

function errMissingExec () {
  local exeName=${1}

  cat <<-ERR
  ERROR: Could not find ${exeName} on PATH.
ERR
  
  exit $(getErrCode MissingExec)
}

function errPathEmpty () {
  local pathSpec=${1}

  cat <<-ERR
  ERROR: No file specified: ${pathSpec}
ERR
  
  exit $(getErrCode PathEmpty)
}

function errPathInaccessible () {
  local path=${1}

  cat <<-ERR
  ERROR: Cannot access file ${path}
ERR
  
  exit $(getErrCode PathInaccessible)
}

function errFileExists () {
  local path=${1}

  cat <<-ERR
  ERROR: File exists: ${path}
ERR

  exit $(getErrCode FileExists)
}

function errMissingPathComponent () {
  local pathSpec=${1}

  cat <<-ERR
  ERROR: Missing path component for spec ${pathSpec}
ERR
  
  exit $(getErrCode MissingPathComponent)
}

function errConfigIncompatible () {
  local expectedVersion=${1}
  local foundVersion=${2}

  cat <<-ERR
  ERROR: Incompatible configuration file format.
  Expected version ${expectedVersion} but found version ${foundVersion}
ERR

  exit $(getErrCode ConfigIncompatible)
}

function errUnsupportedJson () {
  local key=${1}

  cat <<-ERR
  ERROR: Json in unsupported format for key ${key}
ERR

  exit $(getErrCode UnsupportedJson)
}

function errUnrecognizedCommand () {
  local commandSpec="${@}"

  cat <<-ERR
  ERROR: Unrecognized Command: ${commandSpec[*]}

ERR

  printUsage ${0}

  exit $(getErrCode UnrecognizedCommand)
}

### Environment Checks ###

function parsePrelimCommands () {
  if [[ ${#} == 0 ||
        "${@}" == "$(getCommand Help)" ]]; then
    printUsage ${0}
    exit 0
  elif [[ "${@}" == "$(getCommand Init)" ]]; then
    initializeCabalStore
    exit 0
  fi
}

function parseCommands () {
  if [[ "${@}" == "$(getCommand List)" ]]; then
    listInstalledPackages
    exit 0
  elif [[ "${1}" == "$(getCommand Install)" ]]; then
    shift
    installPackages ${@}
    exit 0
  elif [[ "${1}" == "$(getCommand Remove)" ]]; then
    shift
    removePackages ${@}
    exit 0
  elif [[ "${@}" == "$(getCommand Sync)" ]]; then
    synchronizePackages
    exit 0
  else
    errUnrecognizedCommand ${@}
    exit 0
  fi
}

function checkDependencies () {
  local deps=( cabal jq cut )

  for dep in ${deps[@]}; do
    if [[ ! -x $(which ${dep} 2>/dev/null) ]]; then
      errMissingExec ${dep}
    fi
  done
}

function checkConfigVersion () {
  local configVersion=$(getConfigProp Version)

  if [[ $(getConf SupportedVersion) != ${configVersion} ]]; then
    errConfigIncompatible "$(getConf SupportedVersion)" "${configVersion}"
  fi
}


### Package Management Functions ###

function installPackageLocally () {
  local pkg=${1}
  local deps=$(getConfigProp Packages ${pkg} PackageExtraDeps)
  local startDir=${PWD}

  mkdir ${pkg}
  cd ${pkg}

  cabal sandbox init
  cabal install ${deps[@]} ${pkg}

  cd "${startDir}"
}

function removePackage () {
  local pkg=${1}

  rm -r "$(getPath StoreDir ${pkg})"

  for path in $(getBinPaths BinDir ${pkg}); do
    rm -r "${path}"
  done
}

function createPackageSymlinks () {
  local pkg=${1}
  local dir=${2}
  local targets=($(getBinPaths SandboxBinDir ${pkg}))
  local paths=($(getBinPaths BinDir ${pkg}))

  for i in $(seq 0 $(( ${#targets[*]} - 1 )) ); do
    ln -s ${targets[$i]} ${paths[$i]}
  done
}

function makeConfig () {
  local configPath=${1}
  local storePath=${2}
  local binPath=${3}

  cat > "${configPath}" <<-JSON
  {   "$(getConf Description)": "Cabal StoreDir Configuration"
    , "$(getConf Version)": "$(getConf SupportedVersion)"

    , "$(getConf Path)": {
          "$(getConf StoreDir)": "${storePath}"
        , "$(getConf BinDir)": "${binPath}"
      }

    , "$(getConf Packages)": {}
  }
JSON
}


### Command Functions ###

function initializeCabalStore () {
  if [[ ! -e "$(getOpt ConfigPath)" ]]; then
    mkdir -p "$(dirname $(getOpt ConfigPath))"
    makeConfig "$(getOpt ConfigPath)" "$(getOpt StorePath)" "$(getOpt BinPath)"
  else
    errFileExists "$(getOpt ConfigPath)"
  fi

  if [[ ! -e "$(getOpt StorePath)" ]]; then
    mkdir -p "$(getOpt StorePath)"
  else
    errFileExists "$(getOpt StorePath)"
  fi

  if [[ ! -e "$(getOpt BinPath)" ]]; then
    mkdir -p "$(getOpt BinPath)"
  else
    errFileExists "$(getOpt BinPath)"
  fi

}


function installPackages () {
  local packages=${@}
  local startDir=${PWD}

  cd "$(getPath StoreDir)"
  
  for pkg in ${packages[@]}; do
    installPackageLocally ${pkg}
    createPackageSymlinks ${pkg} "$(getPath BinDir)"
  done 
  
  cd "${startDir}"
}

function removePackages () {
  local pkgs=${@}

  for pkg in ${pkgs[@]}; do
    removePackage ${pkg}
  done
}

function synchronizePackages () {
  local installedPkgs=$(ls -1 "$(getPath StoreDir)")
  local declaredPkgs=$(getConfigProp Packages)
  local missingPkgs=$(arrayDifference "${declaredPkgs[*]}" "${installedPkgs[*]}")
  local surplusPkgs=$(arrayDifference "${installedPkgs[*]}" "${declaredPkgs[*]}")

  removePackages ${surplusPkgs[@]}
  installPackages ${missingPkgs[@]}
}

function listInstalledPackages () {
  local pkglist=$(ls -1 $(getPath StoreDir))

  for pkg in ${pkglist[@]}; do
    grep "package: ${pkg}" \
      "$(getPath CabalLog ${pkg})" | cut -d' ' -f2
  done
}


### Initialization Functions ###

function initOpts () {
  local opts=(ConfigPath StorePath BinPath)

  while getopts :s:b:c: OPT; do
    local key=""
    local setopt="false"

    case ${OPT} in
      b) key=BinPath
         setopt="true";;
      s) key=StorePath
         setopt="true";;
      c) key=ConfigPath
         setopt="true";;
      ?) printUsage ${0}
         exit $(getErrCode UnknownArg);;
    esac

    if [[ ${setopt} == "true" ]]; then
      setOpt ${key} "$(realpath ${OPTARG})"
    fi
  done

  for opt in ${opts[@]}; do
    if [[ -z "$(getOpt ${opt})" ]]; then
      setOpt ${opt} "$(getDefault ${opt})"
    fi
  done

  Command[StartIndex]=$((${OPTIND} - 1))
}

function initPaths () {
  setPath Config "$(getOpt ConfigPath)"

  checkConfigVersion

  setPathFromConfig StoreDir
  setPathFromConfig BinDir
}


### Main Execution ###

function main () {
  checkDependencies

  initOpts ${@}
  shift ${Command[StartIndex]}
  
  parsePrelimCommands ${@}

  initPaths
  checkConfigVersion

  parseCommands ${@}

  return 0
}

main ${@}


#--- Module End ---#
}
__init__ ${@}
[[ -n $(typeset -f __init__) ]] && unset -f __init__
